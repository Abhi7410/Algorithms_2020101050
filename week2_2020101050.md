*****************************************************************WEEK-2 LECTURE-1***************************************************************************

4 ALGORITHMS FOR FIBONACCI SERIES

*1.Normal iteration or Memoziation or dynamic programming by storing f[0] and f[1] and then applyfing one loop to count all the values. If the values are very large then this method
is not very feasible because in that case addition also becomes O(n) process.
*2 Recursion , base case of f[0] and f[1] having time complexity of O(2^n).
*3 Matrix multiplication or exponentiation:
   
    [f(n)]      = [1 1]........[f(2)]
    [f(n-1)]      [1 0]........[f(1)]
                  n-2 times
                  
    code for this:
    
vector<vector<int>> a = {{1,1},{1,0}};
vector<vector<int>> ans = matrixExponent(a,n);
int sz = ans.size();
for(int i = 0;i<sz;i++)
{
    for(int j =0;i<sz;j++)
    cout<<ans[i][j];
}

vector<vector<int>> matrixExponentate(vector<vector<int> &a,int n)
 if(n==0)
 int sz = a.size();
 vector<vector<int>> ans(sz,vector<int>(sz,0);
 for(int i = 0,i<sz;i++)
 ans[i][i]=1;
 return ans

 if(n==1)
 return a;

 vector<vector<int>> temp = matrixExponent(a,n/2);

vector<vector<int>> ans = multiply(temp,temp);

if(n%2==1)
 ans = multiply(ans,a);


}

vector<vector<int>> multiply(vector<vector<int>> &a,vector<vector<int>> &b)
{
    int n = a.size();
    vector<vector<int>> ans(n,vector<int>(n,0));

    for(int i = 0;i<n;i++)
    for(int j = 0;j<n;j++)
    for(int k = 0;k<n;k++)
    ans[i][j] += a[i][k]*b[k][j];

    return ans;
}
         
   
 *4: finding the roots as the roots are irrational so we don't consider to use this algo to find the fibonaccy numbers
   
      
      
      
*********************************************************************WEEK-2 LECTURE-2****************************************************************************
      
      
   
   
   
   
   
   
   
   

