
# WEEK-2 LECTURE-1

FIBONACCI NUMBERS ALGORITHMS


## 

1.Normal iteration or Memoziation or dynamic programming by storing f[0] and f[1] and then applyfing one loop to count all the values. If the values are very large then this method
  Since addition is n steps, the below algorithm is hence O(n^2).
```bash
      function fib2(n):
    if n = 0: return 0
    Create an array of f[n]
    f[0] = 0; f[1]=1;
    for i = 2...n:
      f[i] = f[i-1] + f[i-2]
    return f[n];
  
```
2.Recursion , base case of fib[0] and fib[1] having time complexity of O(2^n).
```bash
    function fib1(n):
   if n = 0: return 0
   if n = 1: return 1
   return fib1(n-1) + fib1(n-2) 
  
```
3.Matrix multiplication or exponentiation,
   Runtime complecity:-
   O(M(n)logn), where M(n) is the complexity of multiplying two n-bit integers.
```bash
      vector<vector<int>> a = {{1,1},{1,0}};
      vector<vector<int>> ans = matrixExponent(a,n);
      int sz = ans.size();
      for(int i = 0;i<sz;i++)
      {
        for(int j =0;i<sz;j++)
            cout<<ans[i][j];
       }

    vector<vector<int>> matrixExponentate(vector<vector<int> &a,int n)
      if(n==0)
        int sz = a.size();
      vector<vector<int>> ans(sz,vector<int>(sz,0);
       for(int i = 0,i<sz;i++)
            ans[i][i]=1;
      return ans

     if(n==1)
        return a;

      vector<vector<int>> temp = matrixExponent(a,n/2);

      vector<vector<int>> ans = multiply(temp,temp);

      if(n%2==1)
         ans = multiply(ans,a);


     vector<vector<int>> multiply(vector<vector<int>> &a,vector<vector<int>> &b)
     {
              int n = a.size();
    vector<vector<int>> ans(n,vector<int>(n,0));

    for(int i = 0;i<n;i++)
    for(int j = 0;j<n;j++)
    for(int k = 0;k<n;k++)
    ans[i][j] += a[i][k]*b[k][j];

    return ans;
     }
  
```
4.Finding the roots as the roots are irrational so we don't consider to use this algo to find the fibonaccy numbers
  
- Karatsuba Algorithm:-
  - Used for multiplication of large integers.
  - Primary school solution is of n^2 order since it includes single digit multiplications, additions and shift operations.
  - T(n) = O(n^(1.585)).
  - Idea from multiplication of two complex numbers.
    Real multiplications needed to compute (a+ib) * (c+id) = 4 (Naive answer) --> not the best possible.
    Answer obtained = (ac - bd) + i(ad + bc).
    The idea:-
```bash
     To find (ac - bd) and (ad + bc):
        1. Compute a.c
        2. Compute b.d
        3. Compute (a + b).(c + d)
      Therefore:-
        (ad + bc) = (a + b).(c + d) - ac - bd and hence three multiplications.
       
  
```
# WEEK-2 LECTURE-2
## DIVIDE AND CONQUER:-
 - To multiply two n-digit integers:-
    1. Add two n/2 digit-integers.
    2. Multiply three (n/2)-digit integers. 
    3. Add, subtract and shift (1/2)n-digit integers to obtain result.
    4. MASTER theorem and it's proof using logic tree.

## Merge-Sort:-
  - An O(nlogn) comparison sort
  - Idea:-
      Split the array into two halves and recursily sort each half.
      Then merge the two sorted sub-lists.
  - Merge does a constant amount of work per recursive call which are O(k + 1) calls.
  - And hence merge is indeed linear in n.
  - Time complexity :- O(nlogn)
  - k is atleast log2(n!)
  - Note that there are n! permutations (from 0 to n!-1)..
  - Merge sort is optimal.
  
## Matrix Multiplication:-
  - Naive: O(n^3)
    n * n for multiplication, n for writing it in another matrix resulting in n^3.
  
  - Divide and Conquer:-
    Breaking the matrix into 8 matrix of n/2-sized product.
    Leading into a T(n) = 8T(n/2) + O(n^2) thus entailing O(n^3).
    
  - Strassen's Algorithm:-
      Step 1:- Recursively compute only 7 products.
      Step 2:- Do the necessary additions and subtractions (((theta)n^2) time).
      
      It's better than cubic time as per Master Method.
      Time complexity:- O(n^(2.81))

## Median:-
  - Input: An array of numbers A; and integer k
  - Output: The kth smallest element of A
  
  - Naive: O(nlogn) steps by sorting the array and find the (k-1)th index element from the array/
  
  - Divide and Conquer:-
    ```bash
      Elements smaller than v  
      Those equal to v         
      Those greater than v.    
    ```
    Recursion:
       -              { selection(Sl,k)                  if k <= |Sl|
       -                selection(S,k)={ v               if |Sl| < k <= |Sl| + |Sv|
                     { selection(Sr, k- |Sl|-|Sv|)      if k > |Sl| + |Sv|
      Choosing v:-
       - Deterministic approach:-
          - Median of medians
  
            1. Divide the n elements into groups of 5.
            2. Find the median of each of the n/5 groups.
            3. Find the median x of the n/5 medians.
          - Time complexity: O(n)    
            

    
   
   
   
   
   
   
   
   

