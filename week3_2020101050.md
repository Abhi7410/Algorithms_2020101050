
# WEEK-3 LECTURE-1

## DISCRETE FOURIER TRANSFORM(DFT)
Let there be a polynomial of degree :
```bash
    A(x)= a0+ a1x + a2x^2 + a3x^3 + .............+ an.x^(n-1)                
```
The discrete Fourier transform (DFT) of the polynomial 
  (or equivalently the vector of coefficients is defined as the values of the polynomial at the points.
The theory of complex numbers tells us that the equation x^n=1 has n complex solutions and the solutions
are of the form w^(2kpie)/n.We use DFT to find the product of two polynomials. The pocess using DFT
has time complexity of O(n^2) which is not considered good for large inputs. So we think to optimise the
solution , so new method is formed name FFT.

## FAST FOURIER TRANSFORM(FFT)
The fast Fourier transform is a method that allows computing the DFT in O(nlogn) time. 
The basic idea of the FFT is to apply divide and conquer. We divide the coefficient 
vector of the polynomial into two vectors, recursively compute the DFT for each of 
them, and combine the results to compute the DFT of the complete polynomial.
```bash
    A(x)= a0+ a1x + a2x^2 + a3x^3 + .............+ an.x^(n-1)                
```
We divide it into two smaller polynomials, the one containing only the coefficients of the even positions,
 and the one containing the coefficients of the odd positions.
 ```bash
    A(x)= A0(x^2) + xA1(x^2)                
```
 ```bash
 using cd = complex<double>;
const double PI = acos(-1);

void fft(vector<cd> & a, bool invert) {
    int n = a.size();
    if (n == 1)
        return;

    vector<cd> a0(n / 2), a1(n / 2);
    for (int i = 0; 2 * i < n; i++) {
        a0[i] = a[2*i];
        a1[i] = a[2*i+1];
    }
    fft(a0, invert);
    fft(a1, invert);

    double ang = 2 * PI / n * (invert ? -1 : 1);
    cd w(1), wn(cos(ang), sin(ang));
    for (int i = 0; 2 * i < n; i++) {
        a[i] = a0[i] + w * a1[i];
        a[i + n/2] = a0[i] - w * a1[i];
        if (invert) {
            a[i] /= 2;
            a[i + n/2] /= 2;
        }
        w *= wn;
    }
}
```

# WEEK3 LEC-2

## GREEDY ALGORITHMS
- GRAPHS: MINIMUM SPANNING TREE
A spanning tree of a graph consists of all nodes of the graph and some of the
edges of the graph so that there is a path between any two nodes. Like trees
in general, spanning trees are connected and acyclic.A minimum spanning tree is a
 spanning tree whose weight is as small as possible.

 In Kruskal’s algorithm, the initial spanning tree only contains the nodes of
the graph and does not contain any edges. Then the algorithm goes through the
edges ordered by their weights, and always adds an edge to the tree if it does not
create a cycle.
The algorithm maintains the components of the tree. Initially, each node of
the graph belongs to a separate component. Always when an edge is added to the
tree, two components are joined. Finally, all nodes belong to the same component,
and a minimum spanning tree has been found.
```bash
     
    struct Edge {
    int u, v, weight;
    bool operator<(Edge const& other) {
        return weight < other.weight;
    }
};

    int n;
    vector<Edge> edges;

    int cost = 0;
    vector<int> tree_id(n);
    vector<Edge> result;
    for (int i = 0; i < n; i++)
        tree_id[i] = i;

    sort(edges.begin(), edges.end());

    for (Edge e : edges) {
        if (tree_id[e.u] != tree_id[e.v]) {
            cost += e.weight;
            result.push_back(e);

            int old_id = tree_id[e.u], new_id = tree_id[e.v];
            for (int i = 0; i < n; i++) {
                if (tree_id[i] == old_id)
                    tree_id[i] = new_id;
            }
        }
    }

```
## CUT PROPERTY
According to the cut property, if there is an edge in the cut set which has the smallest edge weight or cost among all
 other edges in the cut set, the edge should be included in the minimum spanning tree.
Shortest path algorithms like Prim’s algorithm and Kruskal’s algorithm use the cut property to construct a minimum spanning tree.




